<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | Dedication</title>
  <meta name="author" content="Ronnie Wang">
  
  <meta name="description" content="Yet another tech blog!">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Dedication"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="Dedication" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-53608123-1', 'auto');
  ga('send', 'pageview');
</script>




</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Dedication</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header">
  <h1>Dedication</h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart"></i>
      You tell me I&#39;m wrong. Then you&#39;d better prove you&#39;re right.
</div>    

		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-07-27 </div>
			<div class="article-title"><a href="/2014/07/27/二叉搜索树与快速排序的内在相似性/" >二叉搜索树与快速排序的内在相似性</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>对我来说，对随机事件的分析，恐怕是最难的。我原以为我数学学得还可以，直到我遇上了随机过程。这篇 blog 所讲的是算法分析，其中涉及到大量对随机情况的分析。因此我在此将其梳理一下，特别注重挖掘不同算法之间的分析过程的相似性。</p>
<p>快速排序是一种原址排序方法，随机化的快排具有 <em>O(nlgn)</em> 的期望运行时间。这个在《算法导论》（第三版）的 7.4.2 节中有一个以比较操作为中心的证明方法。这个证明的核心思想就是：快速排序是由多次 partition 过程组成的，因此关键问题就在于获得 partition 过程的运行时间和运行 partition 过程的次数。partition 过程的最大运行次数是 n-1 次，可以记为 <em>O(n)</em> ，对于其运行时间，练习 7.1-3 给出的结论是 <em>Θ(n)</em> 。这样乍一算，似乎是 <em>O($n^2$)</em> 的时间复杂度。这样计算是错误的，因为 partition 的时间复杂度与其长度有关。这里，我们需要更为细致的分析。决定 partition 运行时间的是其内部循环次数。这个循环次数可以统计每次必须运行的比较次数而得到。通过计算整个 quicksort 的比较次数，我们就可以得到真正的 partition 循环次数。而这个比较次数的期望值，可以通过拆分成示性随机变量相加得到。这个分析的精华之处就在于分析出每两个元素进行比较的概率。很有意思，可以进行比较的组合是 <em>Θ($n^2$)</em> ，但是最终全部比较次数的期望是 <em>O(n lgn)</em> 。</p>
<p>当然这个只是作为复习，不是今天的重点。这个方法实在是太不直观了点。这次我们用类似于 merge-sort 的分析方法进行分析。</p>
<h3 id="快速排序分析">快速排序分析</h3><p>按照 merge-sort 的分析思路，quicksort 是将一个问题拆分成了两个子问题，但是由于子问题大小不是固定的，这时候就只能分析运行时间的期望。随机化的快速排序使得任何一个元素成为主元都是等可能的。因此我们有如下式子：</p>
<span>$$\begin{aligned}
E[T(n)] & =  E \left[ \sum^{n}_{q=1} X_q \left( T(q-1) + T(n-q) + \Theta (n) \right) \right] \\
            & =  \frac{2}{n} \sum^{n-1}_{q=2} E[T(q)] + \Theta (n)
\end{aligned}$$</span>
<p>随后，可以通过代入法，把 <em>n lgn</em> 代入 T(n)。其中，有如下不等式可以利用：</p>
<span>$$\begin{equation}
\sum^{n-1}_{k=2} k \log k \le \frac{1}{2} n^2 \log n - \frac{1}{8} n^2
\end{equation}$$</span>
<p>由于这个不等式的天赐特性，我们只能记住，有如（1）式的结论就是 <em>O(n lgn)</em> 。</p>
<h3 id="二叉搜索树分析">二叉搜索树分析</h3><p>我们知道，二叉搜索树的动态操作时间复杂度是 <em>O(h)</em> 。但是对于随机构建的二叉搜索树来说，其期望树高是 <em>O(n lgn)</em> ，对于随机构建的二叉搜索树来说。这里我们证明的是一个稍弱于此定理的定理：<strong>随机构建的二叉搜索树的平均节点深度为 <em>O(n lgn)</em></strong>。</p>
<p>为表示每一个节点的深度，我们记树<strong><em>T</em></strong>的节点x的深度为 <em>d(x, T)</em> ，而全部节点的深度之和记为 <em>P(T)</em> 。节点平均深度可以表示为</p>
<span>$$\begin{equation}
\frac{1}{n} \sum_{x \in T} d(x, T) = \frac{1}{n} P(T)
\end{equation}$$</span>
<p>而每一棵树可以拆分为节点与左子树、右子树。我们需要注意，当把 P(T) 拆分为$P(T<em>{left})$和$P(T</em>{right})$之后深度还应该增加当前树总节点再减一。也就是</p>
<span>$$\begin{equation}
P(T)=P(T_{left})+P(T_{right})+n-1
\end{equation}$$</span>
<p>对于某一棵树确实是这样。但是这棵树是随机构建的。如何表示出 P(T) 的期望值？事实上，这里和快速排序一样，在随机构建的过程中，第一个元素总是根节点，每一个元素成为第一个元素的概率都是相等的。因此，我们可以据此写出：</p>
<span>$$\begin{equation}
E[P(n)]=E\left[ \frac{1}{n} \sum_{k=0}^{n-1}(P(k)+P(n-k-1)+n-1)\right]
\end{equation}$$</span>
<p>其中 P(n) 是具有 n 个节点的树高。这时候，我们发现，这和在快速排序那里推导出来的式子是非常相似的。因此，延续着快排分析的思路，可以分析出 P(n) = O(n lgn)。</p>
<p>知道这一点有什么用呢？当构建一棵二叉搜索树时，第一个元素会被选为根节点，其后的元素，每一个都要和其比较。这和快速排序的比较次数是一样的。因为当一个元素选为主元的时候，其后的每一个元素都要和其比较。这样，当用相同的序列构建二叉搜索树和进行快速排序的时候，他们所需要的比较次数是相同的。</p>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/07/27/二叉搜索树与快速排序的内在相似性/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-05-30 </div>
			<div class="article-title"><a href="/2014/05/30/简单易懂的XML-parsing——Qt篇/" >简单易懂的XML parsing——Qt篇</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>关于XML的文章我先前写过一篇。之后就再也没写过。原因是很简单的。虽然那篇文章是用Matlab的代码说明XML解析，但是XML的基本概念都是一致的，我也没必要再就C++或是Python等语言再写一遍在其他语言下面怎么用其他的库解析XML，都是大同小异。</p>
<p>可是这个世界上奇葩比较多。最近在做《网络通信原理》的project的时候，用到了Qt里面的QXmlStreamReader。有意思的是，这个东西不按常理出牌。为说明这个特性，我引用Qt 5关于QXmlStreamReader上面的一段话：</p>
<blockquote>
<p>QXmlStreamReader is an incremental parser. It can handle the case where the document can’t be parsed all at once because it arrives in chunks (e.g. from multiple files, or over a network connection).<br>…<br>QXmlStreamReader is memory-conservative by design, since it doesn’t store the entire XML document tree in memory, but only the current token at the time it is reported.</p>
</blockquote>
<p>由这段话我们可以看出，QXmlStreamReader的一个重要特点是，它是一个增量parser。QXmlStreamReader有一个特别的构造函数<code>QXmlStreamReader::QXmlStreamReader(QIODevice * device)</code>，这个device可以是QNetworkReply也可以是QFile。相信这样的好处大家都可以看得出来。为了应付不同IODevice的特性，QXmlStreamReader也只能采取增量解析的方法。然后又有了下面的概念：token.</p>
<p>QXmlStreamReader不在内存中保存全部的DOM tree，现在解析的位置和所解析的对象用token说明。关于什么是token，其实我也不知道。但是QXmlStreamReader提供了一个函数：<code>TokenType QXmlStreamReader::readNext()</code>，有关这个函数的说明是“Reads the next token and returns its type.”</p>
<p>按照官方文档上面的解释，一个可行的解析模型可以是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QXmlStreamReader xml;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (!xml.atEnd()) &#123;</span><br><span class="line">      xml.readNext();</span><br><span class="line">      ... <span class="comment">// do processing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (xml.hasError()) &#123;</span><br><span class="line">      ... <span class="comment">// do error handling</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，QXmlStreamReader在解析xml的时候，以token为单位解析xml文档数据。</p>
<p>我在上一篇文章中讲过，xml有Element node，Element node以Text node作为child，Attribute node从属于Element node，comment node相对独立，而以上四种node都由document node生成，document node可以说是一个xml文档的代表，xml parsing的核心是element node。但是在Qt中，token与这种标准的概念似乎完全无关。它更关心我现在读到的东西是什么。在TokenType的定义中，一共给出了9种不同token的定义，而判断当前parser的tokenType是什么的函数一共有十二种。</p>
<p>我们可以想象，这种parser，一块一块地读取xml文档，只前进不后退，每一块代表一种既定的token，直到全部读完xml为止（也就是<code>atEnd()</code>为真的时候）。</p>
<p>下面让我展示一段我这个project中的一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(reply-&gt;error()==QNetworkReply::NoError)&#123;</span><br><span class="line">    ui-&gt;listWidget-&gt;clear();</span><br><span class="line">    articlelist.clear();</span><br><span class="line">    <span class="function">QXmlStreamReader <span class="title">xml</span><span class="params">(reply)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(xml.readNextStartElement() &amp;&amp; xml.name()==<span class="string">"articles"</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(xml.readNextStartElement() &amp;&amp; xml.name()==<span class="string">"article"</span>)&#123;</span><br><span class="line">            Article record;</span><br><span class="line">            <span class="keyword">while</span>(xml.readNextStartElement())&#123;</span><br><span class="line">                <span class="keyword">if</span>(xml.name()==<span class="string">"author"</span>)&#123;</span><br><span class="line">                    record.author = xml.readElementText();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xml.name()==<span class="string">"date"</span>)&#123;</span><br><span class="line">                    record.date = xml.readElementText();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xml.name()==<span class="string">"title"</span>)&#123;</span><br><span class="line">                    QString t = xml.readElementText();</span><br><span class="line">                    ui-&gt;listWidget-&gt;addItem(t);</span><br><span class="line">                    record.title = t;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xml.name()==<span class="string">"content"</span>)&#123;</span><br><span class="line">                    record.content = xml.readElementText();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            articlelist.push_back(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml文档格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">articles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">author</span>&gt;</span>...<span class="tag">&lt;/<span class="title">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">date</span>&gt;</span>...<span class="tag">&lt;/<span class="title">date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>...<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">content</span>&gt;</span>...<span class="tag">&lt;/<span class="title">content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">article</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">articles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码中reply是个API请求的回应，我的目的是吧这个回应中的每一条信息存放在articlelist中。值得注意的是14-16行那段代码，由于这个是一个增量parser，我们不能使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;listWidget-&gt;addItem(xml.readElementText());</span><br><span class="line">record.title = xml.readElementText();</span><br></pre></td></tr></table></figure>
<p>否则<code>record.title</code>将为空。</p>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/05/30/简单易懂的XML-parsing——Qt篇/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-03-11 </div>
			<div class="article-title"><a href="/2014/03/11/简单易懂的XML-parsing/" >简单易懂的XML parsing</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>读取一个XML文件，返回一个DOM对象。</p>
<p>什么是DOM对象？全称为Document Object Model, XML文件中的每一个东西都对应为一个node。DOM node的属性和方法遵循国际互联网的标准。</p>
<p>有以下类型的nodes：</p>
<ul>
<li>Element nodes*   Text nodes 每一个Text node都是Element node的child</li>
<li>Attribute nodes 不是任何node的parent 或 child,从属于element node</li>
<li>Comment nodes*   Document nodes 只有使用document node的方法才能创造新element, text, attribute, comment</li>
</ul>
<p>现有以下xml文档：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">listitem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span>&gt;</span>Import Wizard<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">callback</span>&gt;</span>uiimport<span class="tag">&lt;/<span class="title">callback</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">icon</span>&gt;</span>ApplicationIcon.GENERIC_GUI<span class="tag">&lt;/<span class="title">icon</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listitem</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">listitem</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>其中的一个label标签有字符Plot Tools。假设你想在同样的listitem里面寻找callback标签的字符：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">findLabel = <span class="string">'Plot Tools'</span>;</span><br><span class="line">findCbk = <span class="string">''</span>;</span><br><span class="line">xDoc = xmlread(fullfile(matlabroot, ...</span><br><span class="line">               <span class="string">'toolbox'</span>,<span class="string">'matlab'</span>,<span class="string">'general'</span>,<span class="string">'info.xml'</span>));</span><br><span class="line">allListitems = xDoc.getElementsByTagName(<span class="string">'listitem'</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">0</span>:allListitems.getLength-<span class="number">1</span></span><br><span class="line">    thisListitem = allListitems.item(k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% Get the label element. In this file, each</span></span><br><span class="line">    <span class="comment">% listitem contains only one label.</span></span><br><span class="line">    thisList = thisListitem.getElementsByTagName(<span class="string">'label'</span>);</span><br><span class="line">    thisElement = thisList.item(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">% Check whether this is the label you want.</span></span><br><span class="line">    <span class="comment">% The text is in the first child node.</span></span><br><span class="line">    <span class="keyword">if</span> strcmp(thisElement.getFirstChild.getData, findLabel)</span><br><span class="line">        thisList = thisListitem.getElementsByTagName(<span class="string">'callback'</span>);</span><br><span class="line">        thisElement = thisList.item(<span class="number">0</span>);</span><br><span class="line">        findCbk = char(thisElement.getFirstChild.getData);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ~<span class="built_in">isempty</span>(findCbk)</span><br><span class="line">    msg = sprintf(<span class="string">'Item "%s" has a callback of "%s."'</span>,...</span><br><span class="line">                      findLabel, findCbk);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   msg = sprintf(<span class="string">'Did not find the "%s" item.'</span>, findLabel);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(msg);</span><br></pre></td></tr></table></figure>
<p>MATLAB本身就提供一个xmlread函数，其返回的是Document Node。根节点哦。其余与Document Node的函数都是标准已经定义了的，这个标准详情请见<a href="http://download.oracle.com/javase/6/docs/api/" target="_blank" rel="external">这里</a>.在上面一段代码中，我们可以看见几个常用的API：</p>
<ul>
<li><code>getElementsByTagName</code>是Document Node的方法，返回一个list。</li>
<li>这个list是node的列表，要得到其中一个元素，需要调用list的<code>item</code>方法。</li>
<li>一个有child的element node，获得其内容，要调用<code>getFirstChild.getData</code>。</li>
</ul>
<p>如果我们想写一个XML文档：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">toc</span> <span class="attribute">version</span>=<span class="value">"2.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"upslope_product_page.html"</span>&gt;</span>Upslope Area Toolbox<span class="comment">&lt;!-- Functions --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"demFlow_help.html"</span>&gt;</span>demFlow<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"facetFlow_help.html"</span>&gt;</span>facetFlow<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"flowMatrix_help.html"</span>&gt;</span>flowMatrix<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tocitem</span> <span class="attribute">target</span>=<span class="value">"pixelFlow_help.html"</span>&gt;</span>pixelFlow<span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">tocitem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">toc</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MATLAB代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">docNode = com.mathworks.xml.XMLUtils.createDocument(<span class="string">'toc'</span>);</span><br><span class="line"></span><br><span class="line">toc = docNode.getDocumentElement;</span><br><span class="line">toc.setAttribute(<span class="string">'version'</span>,<span class="string">'2.0'</span>);</span><br><span class="line"></span><br><span class="line">product = docNode.createElement(<span class="string">'tocitem'</span>);</span><br><span class="line">product.setAttribute(<span class="string">'target'</span>,<span class="string">'upslope_product_page.html'</span>);</span><br><span class="line">product.appendChild(docNode.createTextNode(<span class="string">'Upslope Area Toolbox'</span>));</span><br><span class="line">toc.appendChild(product)</span><br><span class="line"></span><br><span class="line">product.appendChild(docNode.createComment(<span class="string">' Functions '</span>));</span><br><span class="line"></span><br><span class="line">functions = <span class="cell">&#123;<span class="string">'demFlow'</span>,<span class="string">'facetFlow'</span>,<span class="string">'flowMatrix'</span>,<span class="string">'pixelFlow'</span>&#125;</span>;</span><br><span class="line"><span class="keyword">for</span> idx = <span class="number">1</span>:<span class="built_in">numel</span>(functions)</span><br><span class="line">    curr_node = docNode.createElement(<span class="string">'tocitem'</span>);</span><br><span class="line"></span><br><span class="line">    curr_file = <span class="matrix">[functions&#123;idx&#125; <span class="string">'_help.html'</span>]</span>;</span><br><span class="line">    curr_node.setAttribute(<span class="string">'target'</span>,curr_file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% Child text is the function name.</span></span><br><span class="line">    curr_node.appendChild(docNode.createTextNode(functions<span class="cell">&#123;idx&#125;</span>));</span><br><span class="line">    product.appendChild(curr_node);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">xmlwrite(<span class="string">'info.xml'</span>,docNode);</span><br><span class="line">type(<span class="string">'info.xml'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>这个函数首先先创建出一个Document Node，也就是最重要的根节点；</li>
<li><code>SetAttribute</code>是Element Node的方法；</li>
<li>element, text, attribute, comment只能由docNode创建，方法是<code>createXXXNode</code>；</li>
<li>Element Node间的父子关系由<code>appendChild</code>确定。</li>
</ul>
<p>以上就是MATLAB里面处理XML文档的最基本知识。由于XML文档的处理方式是统一的，因此很容易就能拓展到其他语言。从代码中就可以挖掘出许多东西。在实际中，要使用到的XML API恐怕还远远不够。这篇文章只是作为一个入门性质的导引。</p>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/03/11/简单易懂的XML-parsing/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-02-04 </div>
			<div class="article-title"><a href="/2014/02/04/简单易懂的Sublime-Text-2/" >简单易懂的Sublime Text 2</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>由于这几天一看见Python自带的IDLE我就作呕，我觉得很有必要花点时间研究一下<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 2</a>。</p>
<p>为什么要用Sublime Text 2？其实我也不知道。我第一次知道这个编辑器是在Azure的培训上。后来我发现，许多专业人士都非常推崇此编辑器。Sublime Text 2在Windows、Mac和Linux下都有相应的版本。</p>
<p>如果你去看Sublime Text 2的主页，你会发现这个编辑器的最大优点就是多光标编辑。没有其他任何一个编辑器能做到这一点。</p>
<p>下面，我把Sublime的文档简要翻译了一下，权作参考。如果没有特殊说明，下面都是在Windows平台下操作。</p>
<h2 id="大规模行选择">大规模行选择</h2><p><img src="!--￼0--&gt;/img/column-select.png" alt="multiple line selecting"><br>方法一：Shift+右键拖动，或按下中键拖动。<br>如果要额外添加一行光标，使用Ctrl+左键选择。（虽然文档上说Alt是撤销一行光标，但是我从来都没试成功过）<br>方法二：使用键盘：Ctrl+Alt+Up向上选择，Ctrl+Alt+Down向下选择。</p>
<h2 id="多重选择">多重选择</h2><h3 id="选择块区域并分裂成多行">选择块区域并分裂成多行</h3><p>选择一个块区域，然后按下Ctrl+Shift+L，可把一整块的选择区域分成每一行一块的选择区。</p>
<h3 id="快速添加下一相同区域">快速添加下一相同区域</h3><p>我们在文字编辑器里会有相同的变量名，如果我们的光标在其中一个变量名之上，按下Ctrl+D，整个变量名就会被选择。<br>如果再按下Ctrl+D，下一个相同的变量名也会被选择。<br><img src="!--￼1--&gt;/img/multiple-selection.png" alt="multiple block selecting"></p>
<h3 id="一起选定所有相同区域">一起选定所有相同区域</h3><p>光标在变量名上，按下Alt+F3</p>
<h3 id="退回到单个选择模式">退回到单个选择模式</h3><p>按下Esc</p>
<h2 id="自动补全">自动补全</h2><p>自动补全是自动开启的，设置在Preferences/Settings-Default里面，有个”auto_complete”。<br>如果当前弹出窗没有弹出，可以按下Ctrl+空格，强制显示当前可补全选项。不会引发输入法吗，我想。<br>在HTML文档里，’&lt;’键是触发自动补全的按键。</p>
<h2 id="Tab补全">Tab补全</h2><p>Tab补全是自动开启的，有个”tab_completion”的选项。<br>如果当前的补全结果并非为我所愿，可以按下Ctrl+空格，显示补全选框。<br>如果按下Tab不想补全而是写下制表符，可以按下Shift+Tab。</p>
<h2 id="不受干扰模式">不受干扰模式</h2><p>这种模式跟全屏模式还有些区别。<br>View/Enter Distraction Free Mode打开此模式。或直接按Shift+F11。<br>设置不受干扰模式：与上文不同，路径在_Preferences/Settings - More</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    "<span class="attribute">line_numbers</span>": <span class="value"><span class="literal">false</span></span>,  </span><br><span class="line">    "<span class="attribute">gutter</span>": <span class="value"><span class="literal">false</span></span>,  </span><br><span class="line">    "<span class="attribute">draw_centered</span>": <span class="value"><span class="literal">true</span></span>,  </span><br><span class="line">    "<span class="attribute">wrap_width</span>": <span class="value"><span class="number">80</span></span>,  </span><br><span class="line">    "<span class="attribute">word_wrap</span>": <span class="value"><span class="literal">true</span></span>,  </span><br><span class="line">    "<span class="attribute">scroll_past_end</span>": <span class="value"><span class="literal">true</span>  </span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个设置样本。特别注意的是”wrap_width”这个选项，这个选项之大小决定了该模式下的编辑宽度。</p>
<h2 id="Vintage_Mode">Vintage Mode</h2><p>这个是Vi模式。此模式在默认状态下是关闭的，你需要做的是将其从ignored-packages中去除。编辑<code>&quot;ignored_packages&quot;: [&quot;Vintage&quot;]</code>至<code>&quot;ignored_packages&quot;: []</code>即可。</p>
<p>Vintage模式默认状态是insert mode。如有不适请添加如下一行：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"vintage_start_in_command_mode"</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，Vintage模式下的insert模式是Sublime正常工作的模式，在此情况下的vi快捷键不可用。而且Ex模式也不可用。</p>
<p>Ctrl快捷键与Sublime冲突，默认关闭。如需启用，请打开</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"vintage_ctrl_keys"</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="Projects">Projects</h2><p>在Sublime Text 2中，Projects由两个文件组成：</p>
<ul>
<li>Sublime Project File：定义Project，需要加入版本控制；*   Sublime-workspace file：用户的数据。</li>
</ul>
<p>Sublime-Project File是一个JSON文件，顶层分三大部分：Folders明确包含的文件，Settings会覆写用户设置，还有Build_systems。</p>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/02/04/简单易懂的Sublime-Text-2/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-26 </div>
			<div class="article-title"><a href="/2014/01/26/Permalink-404-Error-之解决方案/" >Permalink 404 Error 之解决方案</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>Ike本人在设置wordpress的时候，在settings里面发现了Permalink。从这个页面的主要介绍来看，Permalink的作用就是自定义文章的Link，使之更为结构化和友好。</p>
<p>但是当Ike设置了某个除Default之外的某个Permalink的时候，如果点击一篇发表的文章，就会出现Page Not Found的404错误。</p>
<p>经反复查证，Ike发现Permalink与.htaccess和Apache的设置紧密相关。</p>
<p>如果我们在Settings页面的Permalink中就某个选项进行了保存，wordpress在后台就会改写.htaccess：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BEGIN WordPress</span></span><br><span class="line"><span class="tag">&lt;IfModule mod_rewrite.c&gt;</span></span><br><span class="line"><span class="keyword"><span class="common">RewriteEngine</span></span> <span class="literal">On</span></span><br><span class="line"><span class="keyword">RewriteBase</span> /blog/</span><br><span class="line"><span class="keyword"><span class="common">RewriteRule</span></span> ^index\.php$ -<span class="sqbracket"> [L]</span></span><br><span class="line"><span class="keyword"><span class="common">RewriteCond</span></span> <span class="cbracket">%&#123;REQUEST_FILENAME&#125;</span> !-f</span><br><span class="line"><span class="keyword"><span class="common">RewriteCond</span></span> <span class="cbracket">%&#123;REQUEST_FILENAME&#125;</span> !-d</span><br><span class="line"><span class="keyword"><span class="common">RewriteRule</span></span> . /blog/index.php<span class="sqbracket"> [L]</span></span><br><span class="line"><span class="tag">&lt;/IfModule&gt;</span></span><br><span class="line"><span class="comment"># END WordPress</span></span><br></pre></td></tr></table></figure>
<p>这个.htaccess文件是存放在网页的根目录下的，和wp-config.php存放的位置一样。如果wordpress不能改写此文件，则需要手动改写，但需要注意到的是Ike本人的网页是放在/blog文件夹下的，如果放在别的文件夹下，正确的.htaccess内容可能和上面不一样。</p>
<p>如果成功改写.htaccess，只是成功了一半。因为Ike本人发现即使赋予了后台改写.htaccess的权限，还是不能访问。</p>
<p>有文献报道指出，Apache需要使能rewrite_module才能使得Permalink正常工作。这就需要改写Aapche的配置文件。</p>
<p>运行以下命令：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">find</span> / -<span class="built_in">type</span> <span class="keyword">f</span> -iname <span class="string">"httpd.conf"</span></span><br></pre></td></tr></table></figure>
<p>找到Apache的配置文件的位置。据相关文献报道，需要做的是将</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#LoadModule rewrite_module modules/mod_rewrite.so</span></span><br></pre></td></tr></table></figure>
<p>的注释去掉。</p>
<p>但甚为坑爹的是，Ike发现虚拟机上的Apache配置文件本来就没有把这一行给注释掉。</p>
<p>经过一番查证，这里一篇<a href="https://stackoverflow.com/questions/17206524/404-error-after-changing-permalinks-wordpress" target="_blank" rel="external">帖子</a>为我们给出了解决方案的暗示。于是Ike在配置文件下找到了如下若干行：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># Each directory to which Apache has access can be configured with respect</span></span><br><span class="line"><span class="preprocessor"># to which services and features are allowed and/or disabled in that</span></span><br><span class="line"><span class="preprocessor"># directory (and its subdirectories).</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># First, we configure the "default" to be a very restrictive set of</span></span><br><span class="line"><span class="preprocessor"># features.</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line">&lt;Directory /&gt;</span><br><span class="line">    Options FollowSymLinks</span><br><span class="line">    AllowOverride All</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># Possible values for the Options directive are "None", "All",</span></span><br><span class="line"><span class="preprocessor"># or any combination of:</span></span><br><span class="line"><span class="preprocessor">#   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># Note that "MultiViews" must be named *explicitly* --- "Options All"</span></span><br><span class="line"><span class="preprocessor"># doesn't give it to you.</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># The Options directive is both complicated and important.  Please see</span></span><br><span class="line"><span class="preprocessor"># http://httpd.apache.org/docs/2.2/mod/core.html#options</span></span><br><span class="line"><span class="preprocessor"># for more information.</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line"><span class="preprocessor"># AllowOverride controls what directives may be placed in .htaccess files.</span></span><br><span class="line"><span class="preprocessor"># AllowOverride controls what directives may be placed in .htaccess files.</span></span><br><span class="line"><span class="preprocessor"># It can be "All", "None", or any combination of the keywords:</span></span><br><span class="line"><span class="preprocessor">#   Options FileInfo AuthConfig Limit</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line">    AllowOverride All</span><br></pre></td></tr></table></figure>
<p>按照上面配置，再重启Apache即可。大功告成。</p>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/01/26/Permalink-404-Error-之解决方案/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-26 </div>
			<div class="article-title"><a href="/2014/01/26/坡道的起点——AWS上Wordpress建站小记/" >坡道的起点——AWS上Wordpress建站小记</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>经过若干天的反复瞎搞，这个名为”Pursuing Freedom”的博客终于上线了。</p>
<p>建立一个个人博客本来不是难事，只要你肯花钱。国内国外本来就有很多主机提供商，而且有些还是提供注册域名、服务器搭建的一条龙服务。但是Ike酱认为，有钱首先应该花在手办上，其他的能省就省～上个学期接受了一个Azure的培训，从那个培训中Ike酱得知现在云服务可以做很多事情。而且亚马逊的AWS在一定的使用范围内是免费的，这就提供了无限多的可能构造一个自由定制的主页。下面Ike将会把这次建站的各个方面记录一下，供以后参考。</p>
<p>首先我们从AWS讲起。AWS全称Amazon Web Services。和Windows Azure一样，AWS提供了一系列云解决方案。在注册AWS用户的一年时间之内，可以在限定的范围内，免费使用AWS的部分服务。有关这些详情，请参考<a href="http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-intro/gsg-aws-free-tier.html" target="_blank" rel="external">How Do I Get Started with the Free Usage Tier?</a>。</p>
<p>有必要强调一点的是，注册AWS的账号需要一张国际信用卡。对于弊校学生来说，这还是一件比较容易办得到的事情，因为Ike常常见到食堂附近有建行的人在接受集体办卡。（Ike能说Ike拿到这个信用卡之后的第一件事就是开通了AWS账号么）</p>
<p>建站的过程其实很简单，因为AWS的Documention上已经把步骤都写好了。概要地说，就是使用AWS EC2建立一台虚拟机，进行安全和账户控制，然后在这个虚拟机上安装各式各样的东西～怎样建立一个虚拟机的Instance，怎样通过远程终端连接上去，怎样配置Apache+PHP+MySQL，其实我不是Linux的专家，但是<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/" target="_blank" rel="external">Amazon EC2 User Guide</a>上面都说得一清二楚。别看文档有600页，其实建立个人博客只要前几页就够了。</p>
<p>在这里整理一下，我参考文档的顺序是：<br>1. <a href="http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-intro" target="_blank" rel="external">Getting Started with AWS</a><br>2. <a href="http://docs.aws.amazon.com/gettingstarted/latest/awsgsg-freetier/" target="_blank" rel="external">Getting Started with AWS Free Usage Tier</a><br>3. <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/" target="_blank" rel="external">Amazon EC2 User Guide</a><br>我并不想把这里面的内容再抄一遍放在这里来，说实在的，这一建站步骤唾手可得。</p>
<p>在完成wordpress博客的创建之前，如果有任何问题，都可以归结到文档步骤没有仔细遵循的原因上。总体而言，建立wordpress博客的步骤要比Windows Azure复杂，但是也可以说Windows Azure忽略了许多重要的东西。</p>
<p>但是，在建立了这个wordpress博客、并可以访问之后，是否说明真的可以用了呢？其实后续还有许多复杂的事情要做。</p>
<p>首先就是虚拟机的权限设置问题。在EC2 UG里面，我们给虚拟机创建了一个名为www的group，理由是可以让ec2-user获得对/var/www/的修改权限。但是在实际中，光给ec2-user一个用户这些权限还不够。Wordpress程序可以进行插件的自动安装和自动更新，如果apache拿不到这些权限，Wordpress的更新和拓展都很麻烦。理论上说我们可以每次都登录虚拟机用ec2-user做这些事情，但这样大大提高了博客的使用门槛。</p>
<p>其次，在UG里面没有提到ftp的设置。ftp会给个人网站的部署和更新带来很大便利。wordpress进行更新也需要用到ftp。</p>
<p>关于这两个问题，我给ftp的user和服务器apache都加入到用户组www中，确认网站的根目录下对www都有读写权限。关于ftp的部署，我主要参考了<a href="http://www.chilltouch.com/2013/06/aws-ec2-ftp" target="_blank" rel="external">AWS EC2上架设 FTP</a>。</p>
<p>但是真正麻烦的，是Wordpress服务器经常连接不上数据库的问题。虽然wp-config.php里面的参数都配置正确，但就是无法连接。这个博客其实是第三代博客，就是因为这个问题。一种可能的解决方案是重启虚拟机，但是发现有时候不可行。这个问题Ike参考了许多中外网站，总的来说都不适用。博客所维持时间的长短几乎就取决于什么时候出现这个数据库的问题。</p>
<p>Ike对Linux只是略知皮毛，连鸟哥私房菜第一卷都没看完的战五渣，上面这些问题的解决真的是瞎搞，所以要是把详细的步骤写出来反而有误人子弟之嫌。所以说，建立了这个博客只是站在长长的坡道的起点，以后还要建设邮件系统之类的东西，还要有个像模像样的主页面，但在当前看来最重要的是把MySQL学会。</p>
<p>域名的注册是在Godaddy上注册的，原来想用ikely.cc以暗示真名，或是ike.ly，但是.me的域名实在是便宜，10刀一年。域名前面原来有www，要去掉www很简单，只要在Godaddy的域名转发里面设置子域名转发就可以了。</p>

	
	</div>
	
  
</div>
	<a type="button" href="/2014/01/26/坡道的起点——AWS上Wordpress建站小记/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-07-20 </div>
			<div class="article-title"><a href="/2013/07/20/关于-CUDA-中-reduction-运算的优化/" >关于 CUDA 中 reduction 运算的优化</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
  
	<div class="col-md-12">
	  
	
	  <p>最近在Udacity上学习有关基于CUDA的并行运算。在学习当中除了Udacity上面所给的资源以外，我本人还查找了很多其他资料。我计划把我所查找到的这些资料写成技术blog，以供以后查阅。</p>
<p>在Unit 3当中，讲到了三种常见的并行运算：reduce、scan和histogram。简单地讲，reduce运算的输入是一个数据集，和一个运算符（二值，结合性），输出为一个数据，其为数据集中的数据依次与运算符相作用后的结果，如求和、求最大值、求最小值都是reduce. Scan运算的输入是一个数组，一个二值运算符和一个identity element. 这个identity element正如0之于加，1之于乘。常见的scan运算为求累积概率。当然我这种说法很不科学，只要能意会就行了。</p>
<p>最常见的reduce算法就是利用了完全二叉树的结构，分两步完成：</p>
<p>对于这一算法的实现，文献[1]以七种算法的逐级演进说明了reduce的优化过程。下面主要讲讲这个优化思想和过程。</p>
<p>首先一种是二叉树结构的直接实现算法，interleaved addressing:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">reduce0</span><span class="params">(<span class="keyword">int</span> *g_idata, <span class="keyword">int</span> *g_odata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">extern</span> __shared__ <span class="keyword">int</span> sdata[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// each thread loads one element from global to shared mem</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tid = threadIdx.x;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = blockIdx.x*blockDim.x + threadIdx.x;</span><br><span class="line">sdata[tid] = g_idata[i];</span><br><span class="line">__syncthreads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do reduction in shared mem</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> s=<span class="number">1</span>; s &lt; blockDim.x; s *= <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tid % (<span class="number">2</span>*s) == <span class="number">0</span>) &#123;</span><br><span class="line">             sdata[tid] += sdata[tid + s];</span><br><span class="line">         &#125;</span><br><span class="line">     __syncthreads();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write result for this block to global mem</span></span><br><span class="line"><span class="keyword">if</span> (tid == <span class="number">0</span>) g_odata[blockIdx.x] = sdata[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于红字那一段，高度分支结构会导致性能下降，因此利用strided index将其修改成非分支结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> s=<span class="number">1</span>; s &lt; blockDim.x; s *= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">2</span> * s * tid;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; blockDim.x) &#123;</span><br><span class="line">        sdata[index] += sdata[index + s];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于偶数strided index会产生bank conflicts（以后会讲什么是bank conflicts），我们将其改进为sequential addressing:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> s=blockDim.x/<span class="number">2</span>; s&gt;<span class="number">0</span>; s&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tid &lt; s) &#123;</span><br><span class="line">         sdata[tid] += sdata[tid + s];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sequential addressing中，红字凸显的部分说明有一半的线程在第一循环迭代的时候就处于空闲状态。为了改进，我们采用first add during load技术。简单地说，我们采用上述过程一半的block，在刚进入线程的时候就进行一次operation，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// perform first level of reduction,</span></span><br><span class="line"><span class="comment">// reading from global memory, writing to shared memory</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tid = threadIdx.x;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = blockIdx.x*(blockDim.x*<span class="number">2</span>) + threadIdx.x;</span><br><span class="line">sdata[tid] = g_idata[i] + g_idata[i+blockDim.x];</span><br><span class="line">__syncthreads();</span><br></pre></td></tr></table></figure>
<p>我认为将代码优化到这一地步已经足够了，但是令我惊讶的是，文献[1]进行了如下分析：当前代码的带宽仍没有达到GPU的上限，究其原因，由于对于核心运算的不是存储、运算的辅助性指令造成了代码的瓶颈，代码没有达到最大性能。解决的办法就是拆开循环。</p>
<p>分析指出，当s&lt;=32时，有效线程减少至一束（wrap）。一束线程是SIMD（单指令多数据） synchronous的。这就意味着s&lt;=32时不需要__syncthreads()和if (tid &lt; s)。因此，我们可以拆解最后六个循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> s=blockDim.x/<span class="number">2</span>; s&gt;<span class="number">32</span>; s&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tid &lt; s)</span><br><span class="line">    sdata[tid] += sdata[tid + s];</span><br><span class="line">    __syncthreads();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tid &lt; <span class="number">32</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">32</span>];</span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">16</span>];</span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">8</span>];</span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">4</span>];</span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">2</span>];</span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，这减少了所有线程束的无用功，而不仅仅是最后一个线程束。</p>
<p>进一步地，该文献还指出，在已知迭代数的情况下，可以完全拆解循环。在只讨论二的n次方大小的数组时，我们通过模板，给出blocksize，就可以给出一个通用的reduce算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (blockSize &gt;= <span class="number">512</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tid &lt; <span class="number">256</span>) &#123; sdata[tid] += sdata[tid + <span class="number">256</span>]; &#125; __syncthreads();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blockSize &gt;= <span class="number">256</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tid &lt; <span class="number">128</span>) &#123; sdata[tid] += sdata[tid + <span class="number">128</span>]; &#125; __syncthreads();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blockSize &gt;= <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tid &lt; <span class="number">64</span>) &#123; sdata[tid] += sdata[tid + <span class="number">64</span>]; &#125; __syncthreads();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tid &lt; <span class="number">32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">64</span>) sdata[tid] += sdata[tid + <span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">32</span>) sdata[tid] += sdata[tid + <span class="number">16</span>];</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">16</span>) sdata[tid] += sdata[tid + <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">8</span>) sdata[tid] += sdata[tid + <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">4</span>) sdata[tid] += sdata[tid + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">2</span>) sdata[tid] += sdata[tid + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数声明变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> blockSize&gt;</span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">reduce5</span><span class="params">(<span class="keyword">int</span> *g_idata, <span class="keyword">int</span> *g_odata)</span></span></span><br></pre></td></tr></table></figure>
<p>最后，文献指出，通过算法级联的思想，可以把上文中first add during load变成multiple add.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tid = threadIdx.x;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = blockIdx.x*(blockSize*<span class="number">2</span>) + threadIdx.x;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> gridSize = blockSize*<span class="number">2</span>*gridDim.x;</span><br><span class="line">sdata[tid] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    sdata[tid] += g_idata[i] + g_idata[i+blockSize];</span><br><span class="line">    i += gridSize;</span><br><span class="line">&#125;</span><br><span class="line">__syncthreads();</span><br></pre></td></tr></table></figure>
<p>注意这个是更改的开头部分。</p>
<p>参考文献：</p>
<p>[1] <a href="http://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf" target="_blank" rel="external">Optimizing Parallel Reduction in CUDA - Nvidia</a></p>

	
	</div>
	
  
</div>
	<a type="button" href="/2013/07/20/关于-CUDA-中-reduction-运算的优化/#more" class="btn btn-default more">阅读此文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
          <li class="next disabled"><a>下一页<i class="fa fa-arrow-circle-o-right"></i></a></li>
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			<div class="form-group has-success has-feedback">
  <form action="//google.com/search" method="get" accept-charset="utf-8" >
    <input type="search" name="q" results="0" placeholder="搜索" class="form-control">
    <input type="hidden" name="q" value="site:wattlebird.github.io">	
  </form>
</div>

		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Analytical/">Analytical<span>2</span></a></li>
		
			<li><a href="/categories/Notes/">Notes<span>6</span></a></li>
		
			<li><a href="/categories/OJ-Review/">OJ Review<span>5</span></a></li>
		
			<li><a href="/categories/Projects/">Projects<span>3</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/Algorithm/">Algorithm<span>7</span></a></li>
		
			<li><a href="/tags/xml/">xml<span>2</span></a></li>
		
			<li><a href="/tags/Coursera/">Coursera<span>3</span></a></li>
		
			<li><a href="/tags/Data-Structure/">Data Structure<span>3</span></a></li>
		
			<li><a href="/tags/sublime-text-2/">sublime text 2<span>1</span></a></li>
		
			<li><a href="/tags/Game-theory/">Game theory<span>3</span></a></li>
		
			<li><a href="/tags/wordpress/">wordpress<span>2</span></a></li>
		
			<li><a href="/tags/CUDA-C/">CUDA C<span>1</span></a></li>
		
			<li><a href="/tags/tools/">tools<span>1</span></a></li>
		
			<li><a href="/tags/Backend/">Backend<span>2</span></a></li>
		
			<li><a href="/tags/apache/">apache<span>2</span></a></li>
		
			<li><a href="/tags/Machine-Learning/">Machine Learning<span>1</span></a></li>
		
			<li><a href="/tags/C/">C++<span>7</span></a></li>
		
			<li><a href="/tags/matlab/">matlab<span>1</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2015/05/01/test/" ><i class="fa fa-file-o"></i>test...</a>
      </li>
    
      <li>
        <a href="/2015/04/26/Combination-Sum/" ><i class="fa fa-file-o"></i>Combination Sum...</a>
      </li>
    
      <li>
        <a href="/2015/03/08/How-I-build-up-Chi-同步率改-v0-3-实现细节/" ><i class="fa fa-file-o"></i>How I build up Chi: 同步率改 v0...</a>
      </li>
    
      <li>
        <a href="/2015/01/17/Misha-and-Permutations-Summation/" ><i class="fa fa-file-o"></i>Misha and Permutations Summ...</a>
      </li>
    
      <li>
        <a href="/2015/01/03/OJ-总结-Depricated/" ><i class="fa fa-file-o"></i>OJ 总结(Depricated)...</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/wattlebird" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2015 Ronnie Wang
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>


<script type="text/javascript">
var disqus_shortname = 'wattlebirdgithubio';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
   </html>
